## c++常见问题
- const的作用
    - 成员函数后加const修饰，是修饰this指针，this指针指向的内容不能更改
    - const就近修饰原则
        - `const char * p1`，修饰*p1，即指针指向的内容不可更改
        - `char const * p2`，修饰*p2，指针指向的内容不可更改
        - `char * const p3`, 修饰p3，指针本身不能更改
- static的作用
    -  隐藏，尽在作用域内有效
    -  持久化，局部变量只能初始化一次，变量放在数据区
- new和malloc区别
    - new运算符，可以被重载，分为三步，申请内存、基于内存进行构造、返回内存指针
    - malloc，只是用于申请内存
    - 另外placement new()，`auto pr = new(ptr) int`，基于已有内存的构造，即new的第二步；
- 单例模式的double check问题

- 只能在堆上创建，不在在栈上创建
    - 析构函数私有化
    - 在成员函数中，重载new和delete
- inline和宏的区别
    - 宏，是直接执行代码替换，没有参数校验
    - inline就是正常的函数，省去了参数的压栈、出栈，减少调用开销
    - inline
- 多态
    - 基于虚表的多态
      - 基类有虚函数，所有的实例都维护一个指向虚表的指针；
      - 虚表内部按照虚函数的定义顺序排序；
      - 派生类重写的函数地址，会将虚表中基类的函数地址给替换掉；这样，只用基类指针，就可以访问派生类的函数实现；
- 虚析构函数
    - 基类加虚析构函数，会自动触发，先析构派生，后析构当前，防止内存泄漏
    - 删除对象时，派生类的析构和基类的析构构成多态，所以先调用派生类的析构；析构函数
    - 参考：https://www.zhihu.com/question/268022905